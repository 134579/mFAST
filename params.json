{"name":"mFAST","tagline":"A FAST (FIX Adapted for STreaming) encoder/decoder","body":"Introduction\r\n--------------\r\n\r\nIn the financial domain, FAST (FIX Adapted for STreaming) is a data compression technology used to meet the challenge of transferring huge volumes of market data between financial institutions with low latency. It is a standard developed by FIX Protocol Ltd., specifically aimed at optimizing data representation on the network. Although it was initially designed for the financial industry, the application of it is not specific to market data. It can be applied to other domains which require data transfers with high throughput and low latency.\r\n\r\nPreviously, OCI has developed an open source native C++ implementation of the FAST Protocol, QuickFAST[www.quickfast.org]. In recent months, however, OCI has identified approaches to further optimize the processing of FAST messages and simplify its use. Some of the features of this new approach include avoiding in-memory data representation for application types that are not type safe; accessing the data structure which does not require the use of string comparison; an alternative to the use of reference counted pointers for small objects to improve space and speed efficiency. The result of this effort is a new open source product called mFAST which was developed from the ground up to provide an easy to use and yet more efficient FAST encoder/decoder. Like QuickFAST, mFAST is also implemented in C++. However, mFAST incorporates some advanced techniques such as region-based memory management and the flyweight and visitor design patterns. These make mFAST more user friendly and significantly more efficient than QuickFAST.\r\n\r\nCompared to QuickFAST, mFAST offers the following features:\r\n\r\n### An easier to use application type system\r\nThe FAST encoding is performed in accordance with a control structure called a template. A template controls the encoding of the stream by specifying the order and structure of fields, their field operators and the binary encoding representations to use. A FAST template is defined with a concrete syntax using XML format. One of the most distinctive advances of mFAST over QuickFast is its ability to generate C++ application types using the XML specification. If you are familiar with CORBA or DDS, this process is tantamount to the proxy/stub code generation using an IDL compiler.\r\n\r\n### Lower external dependencies\r\nIn addition to the C++ standard library, the core mFAST library uses header-only BOOST libraries to provide platform portability. In addition, it uses TinyXML2 for XML parsing. TinyXML2 has only one source and one header file and it is statically linked to mFAST applications.\r\nQuickFAST, on the other hand, requires several non-header only libraries (thread, system, file systems, etc) and Xerces.\r\n\r\n### Smaller memory footprint\r\nIn our measurements, mFAST applications are about 30 to 50 percent of their QuickFAST counterparts, depending on whether the applications are decoder/encoder only or using both, and also on whether the applications use offline type generation.\r\n\r\n### Better runtime efficiency\r\nBased on our evaluation on a data stream of 30000 messages, mFAST decoder is nearly 8 times faster and the encoder is more than 12 times faster than QuickFAST.\r\n\r\n\r\nEvaluation\r\n--------------------\r\nIn this section, we evaluate the memory footprint and runtime performance of applications developed on top of mFAST and QuickFAST.  All of the evaluation is performed on a 2009 Macbook Pro with 2.26 GHZ Intel Core 2 Duo CPU. The OS used is Mac OS/X 10.8.4. Applications are compiled with Apple LLVM version 4.2 with libstdc++. Both mFAST and QuickFast use BOOST version 1.54.0. In addition, QuickFAST is dependent on Xeres (version 3.1 used) while mFAST has no such dependency.\r\n\r\n### Memory Footprint Comparison\r\nThe core of mFAST is a unique and very compact application type system and all additional functionality, such as  the FAST decoder and encoder, are implemented as visitors and can be linked to applications independently. This makes the mFAST library very modular.  For example, if the FAST encoder is not needed for an application, it need not be linked into the application and it won't consume the memory footprint of the application executable. On the other hand, QuickFAST does not exhibit such fine grain modularity. The encoder and decoder are in the same module and inseparable without a significant effort to refactor the code.\r\n\r\nTo see how small an mFAST application is compared to that of QuickFAST. We implemented two test programs to decode a FAST data stream in a file using mFAST. One of them (named mf\\_fixed\\_decode) used  mFAST type generator to produces application types on a sample FAST XML file and then used the generated type to drive the decoder. The second test program (mf\\_generic\\_decode) directly parsed a FAST specification into memory and used the parsed information to drive the decoder without the code generation step.To understand the encoder affect the footprint, we also modify the above programs to re-encode the messages right after decoding. The modified programs are named  mf\\_fixed\\_decode\\_encode and mf\\_generic\\_decode\\_encode.\r\n\r\nOn the QuickFAST side, we used the PerformanceTest located in the QuickFAST example directory for comparison. Like mFAST mf_generic_\\decode, the QuickFAST PerformanceTest program parsed a FAST specification on the fly and decoded an input data stream from a file. However, it did not assemble the decoded messages. Instead, it notified the application via a callback object. Whenever there's a new data field to be processed, the QuickFAST decoder invokes the callback object to provide the name of the data field and the decoded value.\r\n\r\nQuickFAST also has a GenericMessageBuilder class which actually builds an entire message. In order to provide a functional equivalent program to our mFAST counterparts (because both mf\\_fixed\\_decode and mf\\_generic\\_decode actually build entire messages), we modified the original PerformanceTest to use the GenericMessageBuilder (coupled  with a NullMessageConsumer) and named the modified program as qf_generic_decode. Similarly, qf\\_generic\\_decode\\_encode is the QuickFAST equivalent of mf\\_generic\\_decode\\_encode.\r\n\r\nOn the other hand, the decoded results from QuickFAST PerformanceTest program cannot be fed back to QuickFAST encoder API  because it requires  assembled messages. Therefore, we don't have the re-encode equivalent of QuickFAST PerformanceTest.\r\n\r\nTo make fair comparison, both mFAST and QuickFAST libraries are statically linked into their respective applications. However, Xerces and some other BOOST run-time libraries which QuickFAST depended on were still dynamically linked into the executables. On the other hand,  the BOOST library used by mFAST is header only; there is neither link dependency on BOOST nor on Xerces for mFAST.\r\n\r\nThe following  are the sizes of executables compiled  using -O3 flag without debug information.\r\n\r\n* mf\\_fixed\\_decode : 460,448 bytes\r\n* mf\\_fixed\\_decode\\_encode : 575,848 bytes\r\n* mf\\_generic\\_decode : 610,948 bytes\r\n* mf\\_generic\\_decode\\_encode : 726,364 bytes\r\n* QuickFAST PerformanceTest : 1,292,688 bytes\r\n* qf_generic_decode : 1,417,000 bytes\r\n* qf_generic_decode\\_encode : 1,427,220 bytes\r\n\r\nAs you can see, the mFAST executables are about 30% to 40% of the QuickFAST versions; which is quite a reduction, not to mention that mFAST versions do not link to other dynamic libraries as their QuickFAST counterparts.\r\n\r\n### Runtime Efficiency Comparison\r\nTo compare the runtime performance of mFAST and QuickFAST, we used the above test programs to decode a data stream file with 30000 messages. The following were the execution times for the programs.\r\n\r\n* mf\\_fixed\\_decode  : 115 msec\r\n* mf\\_fixed\\_decode\\_encode : 251 msec\r\n* mf\\_generic\\_decode : 117 msec\r\n* mf\\_generic\\_decode\\_encode : 262 msec\r\n* QuickFAST PerformanceTest : 144 msec\r\n* qf_generic_decode : 920 msec\r\n* qf_generic_decode\\_encode : 2710 msec\r\n\r\n\r\nAs we can see from the above numbers, mFAST performance was much improved over QuickFAST. For decoding FAST messages, mf\\_generic\\_decode was about 23% faster than QuickFAST PerformanceTest. Given that QuickFAST PerformanceTest did not actually assemble entire messages as mf\\_generic\\_decode did, that was not a fair comparison. When comparing mf\\_generic\\_decode with its QuickFAST functionally equivalence, namely qf_generic_decode, mFAST was 7.8 times faster than its QuickFAST counterpart.  To get the performance of FAST encoding, we used the execution times from the decode\\_encode programs and subtracted from the data collected from the decode-only programs. The end result: mFAST was 12.3 times faster than QuickFAST.\r\n\r\n\r\nGetting Started with mFAST\r\n-------------------\r\n### Prerequisite\r\n\r\nmFAST is dependent on the following tools/libraries:\r\n\r\n* BOOST 1.53 or higher [http://www.boost.org]\r\n* CMake 2.8.8 or higher [http://cmake.org]\r\n* tinyXML2 [http://www.grinninglizard.com/tinyxml2] (setup as a submodule in the git repository)\r\n\r\n### Building the code\r\nmFAST uses CMake as its build system. On Unix systems, you can simply following the instruction below to compile the code.\r\n\r\n    $ cd mfast\r\n    $ mkdir build\r\n    $ cd build\r\n    $ cmake ..\r\n    $ make\r\n\r\nThis uses the CMake out-of-source building approach to compile the code. You can also use `make install` to install the built library and tool into the system predefined path (/usr/local). For convenience, we will refer the build directory as `$MFAST_BUILD_DIR`.\r\n\r\nThe build system can be configured via `-DOption=Value` syntax when invoking cmake. Here are a list of commonly used configuration options applicable to  mFAST.\r\n\r\n* CMAKE\\_BUILD\\_TYPE : Specify the building mode such as debug or release. Valid values are\r\n    - None (default)\r\n    - Debug\r\n    - Relase\r\n    - RelWithDebInfo\r\n    - MinSizeRel\r\n* BUILD\\_SHARED\\_LIBS : whether to build mFAST as shared/dynamic linked library. Valid values are ON and OFF with default OFF. If the value is ON,  both static and shared library would be built. Notice that for application to link against mFAST shared libraries, the preprocessor macro MAST\\_DYN\\_LINK must be defined for the application sources.\r\n* BOOST\\_ROOT : specify the root directory for your BOOST installation. If you have a problem with the build system finding your BOOST installation after specifying BOOST_ROOT, use `cmake --help-module FindBoost` in the command line to get further information.\r\n* CMAKE\\_INSTALL\\_PREFIX : specify the installation prefix for mFAST libraries and code generation tool.\r\n\r\nTo make sure mFAST will work correctly on your platform, you can run the unit test program `$MFAST_BUILD_DIR/tests/mfast_test`.\r\n\r\nOn a Microsoft Windows system with MSVC, you can download the CMake GUI tool to generate MSVC project files. The building process and unit test program require the boost DLLs; therefore make sure the BOOST DLL path is in your PATH environment variable before compiling mFAST.\r\n\r\n\r\n### Basics of FAST templates\r\nBefore we dive into the detail of the mFAST APIs, we need to briefly introduce the FAST template specification to facilitate our further discussion. Conceptually, a FAST template is similar to a `struct` in the C language. It contains one or more fields of primitive types, groups or sequences. For the FAST specification version 1.1, there are only 7 primitive types: int32, uInt32, int64, uInt64, decimal, string and byteVector. A string type can be further divided into ASCII and unicode string types. A group is similar to a nested struct in C. It comprises an ordered set of other fields. A sequence is a repeated group similar to vector of structure in C++. In addition, it is also possible to nest another template inside a template, in which case the field is called `templateRef`. A `templateRef` field can have a specified name or not. A templateRef with a name specified is called static templateRef whereas a templateRef without a name specified is called dynamic templateRef. A static templateRef is treated as if the content of the referenced template is directly copied into the referencing template under the FAST encoding rule. A  dynamic templateRef, on the other hand, can be assigned to any value of a template recognizable to the encoder/decoder at runtime. In a certain sense, it is a way of accommodating an 'ANY' type in FAST. It can, however, only used to embed other templates, not to embed other primitive types, groups or sequences.\r\n\r\nExcept for templateRef, all fields can be declared as mandatory or optional.  Primitive type fields, in addition, can be specified with an `instruction context` which describes how the value of a field  can be interpreted relative to its previous value of the same field. For example, a `constant` instruction means the value of the field can never change except for it can be absent when the field is optional. A field with a copy instruction means the decoder should interpret the value of the field as its previous value when value is not present in the encoded stream. Otherwise, the value of the field is the same with the value on the stream.\r\n\r\n\r\nThe following fragment of XML is an example of a template definition:\r\n\r\n    <templates xmlns=\"http://www.fixprotocol.org/ns/template-definition\"\r\n               templateNs=\"http://www.fixprotocol.org/ns/templates/sample\"\r\n               ns=\"http://www.fixprotocol.org/ns/fix\">\r\n    <template name=\"MDRefreshSample\" id='10001'>\r\n        <string name=\"BeginString\" id=”8”> <constant value=\"FIX4.4\"/> </string>\r\n        <string name=\"MessageType\" id=”35”> <constant value=\"X\"/> </string>\r\n        <string name=\"ApplVerID\" id=\"1128\" presence=\"optional\"> <copy/> </string>\r\n        <string name=\"SenderCompID\" id=”49”> <copy/> </string>\r\n        <uInt32 name=\"MsgSeqNum\" id=”34”> <increment/> </uInt32>\r\n        <sequence name=\"MDEntries\">\r\n            <length name=\"NoMDEntries\" id=”268”/>\r\n            <uInt32 name=\"MDUpdateAction\" id=”279”> <copy/> </uInt32>\r\n            <string name=\"MDEntryType\" id=”269”> <copy/> </string>\r\n            <string name=\"Symbol\" id=”55”> <copy/> </string>\r\n            <string name=\"SecurityType\" id=”167”> <copy/> </string>\r\n            <decimal name=\"MDEntryPx\" id=”270”> <delta/> </decimal>\r\n            <decimal name=\"MDEntrySize\" id=”271”> <delta/> </decimal>\r\n            <uInt32 name=\"NumberOfOrders\" id=”346”> <delta/> </uInt32>\r\n            <string name=\"QuoteCondition\" id=”276”> <copy/> </string>\r\n            <string name=\"TradeCondition\" id=”277”> <copy/> </string>\r\n        </sequence>\r\n    </template>\r\n    </templates>\r\n\r\nTo minimize the memory usage for applications in non-financial domains, mFAST supports 4 additional primitive types not in the FAST specification. They are int32Vector, uInt32Vector, int64Vector and uInt64Vector. These integer vector types have similar APIs to byteVector; however, neither *operator* nor *initial value* are supported for integer vectors. In essence, a field specified as `<int32Vector name=\"myfield\" id=\"1\" />` would be encoded exactly as follows:\r\n\r\n  <sequence name=\"myfield\" id=\"1\">\r\n    <int32 name=\"element\"/>\r\n  </sequence>\r\n\r\n\r\n### Generating C++ classes from FAST XML specification files\r\n\r\nmFAST provides two approaches to incorporate FAST template specification into applications. The first (and preferred) approach is using the tool `fast_type_gen` to  generate C++ types for corresponding FAST templates. Using the generated C++ types makes it easier to read/write application code and provides stronger type safety. It also eliminates the need to parse the XML specification at runtime and thus reduce application memory footprint. The `fast_type_gen` tool is located under the `$MFAST_BUILD_DIR/bin` directory. At current stage, it only takes FAST XML files as its arguments and generating C++ files without any options like the following.\r\n\r\n    $MFAST_BUILD_DIR/bin/fast_type_gen test1.xml test2.xml\r\n\r\nFor each XML specification file, `fast_type_gen` will generate three files (.h, .inl and .cpp) with the base name of those generated files and the same with their corresponding xml file. The C++ namespace of the generated C++ classes are also the same with the base filename. Currently, There is no other way to change the namespace unless you change the filename of the input XML file or directly modify the generated code.\r\n\r\nIf your input XML specification files have dependencies among them, all input files must be generated at once; i.e. you cannot do something like `fast_type_gen input1.xml` and then `fast_type_gen input2.xml` if input2.xml is dependent on input1.xml. An input FAST specification file A is only dependent on another file B if and only if B contains a static templateRef where the name of templateRef is only defined in A. In addition, `fast_type_gen` cannot handle circular dependency between its input files.\r\n\r\nTo encode/decode FAST messages correctly, each FAST template must have a unique template identifier. The specification does not define how to map template names to template identifiers. In our implementation, we choose to use the number specified by the `id` attribute in the  template definition, as the template identifier for encoder/decoder purposes. Furthermore, even though  FAST specification does not have any restriction on what the id attributes for fields can be,  `fast_type_gen` can  generate valid C++ code only when the value for id attributes are unsigned 32 bits integers.\r\n\r\nThere are some limitations in the current implementation of mFAST. For one, `fast_type_gen` is not robust enough to report syntactic or semantic errors from its input files. It's possible that the code generation process can succeed and yet the generated code won't compile or even executed correctly if errors exist in its input files. For example, if the names of templates or fields are not valid C++ identifiers, the generated code would not compile. This is an issue to be addressed in the future release of this product.\r\n\r\nAnother approach to use a template specification is to explicitly read the XML file in the application; however, this approach loses type safety and the XML parser would increase the application memory footprint. We will further discuss the API for this approach later.\r\n\r\n\r\nFAST Template to mFAST C++ Type Mapping\r\n--------------------------------------\r\n\r\nIn order to maximize the space efficiency of deserialized FAST messages while providing a user friendly API,  mFAST employs a very unique mapping of FAST templates to C++ types.  Unlike OMG IDL/C++ type mapping or Google Protocol Buffers, where each message type is represented by a C++ struct/class and the struct/class is responsible for  resource management as well as providing getter/setter functions for accessing field values; mFAST separates those roles into different C++ classes. For the previous mentioned example FAST template  `MDRefreshSample`, three C++ classes named `MDRefreshSample`, `MDRefreshSample_cref` and `MDRefreshSample_mref` are generated by `fast_type_gen`. Based on their functionalities,  we name them as *value holder*, *constant reference* and *mutable reference* classes respectively.\r\n\r\nA value holder class manages the internal resources needed by fields of a message, it does not provide  getters/setters to read or write its contained fields. The member functions it provides only allows you to construct/copy the value or to create the reference objects. Suppose the previous mentioned FAST templates XML is saved as 'example.xml', the generated `MDRefreshSample` would be as follows.\r\n\r\n\r\n```\r\n// example.h, generated from fast\\_type\\_gen example.xml\r\nnamespace example {\r\n\r\nclass MDRefreshSample_cref\r\n: public mfast::message_cref {\r\n// ...\r\n};\r\n\r\nclass MDRefreshSample_mref\r\n: public MDRefreshSample_cref {\r\n// ...\r\n};\r\n\r\nclass MDRefreshSample\r\n: private boost::array<mfast::value_storage, 6>\r\n, public mfast::message_type\r\n{\r\npublic:\r\n  enum {\r\n    the_id = 10001\r\n  };\r\n  MDRefreshSample(\r\n    mfast::allocator* alloc=mfast::malloc_allocator::instance());\r\n\r\n  MDRefreshSample(\r\n    const MDRefreshSample_cref& other,\r\n    mfast::allocator* alloc=mfast::malloc_allocator::instance());\r\n\r\n  MDRefreshSample_cref ref() const;\r\n  MDRefreshSample_cref cref() const;\r\n  MDRefreshSample_mref ref();\r\n  MDRefreshSample_mref mref();\r\nprivate:\r\n  MDRefreshSample(const MDRefreshSample&);\r\n  MDRefreshSample& operator = (const MDRefreshSample&);\r\n};\r\n\r\nmfast::templates_description* description();\r\n\r\n} // namespace example\r\n```\r\n\r\n\r\nConstant and mutable reference objects, on the other hand, are used for reading/writing field values, testing the presence of a field, and querying field meta data. Each type in FAST specification, whether primitive or not, has its own representative constant/mutable reference classes. The following figure is the UML representation for the basic constant reference classes.\r\n\r\n![Figure 1. mFAST constant reference class hierarchy](figures/cref.svg)\r\n\r\nAt the center of figure is the `field_cref` class, which is the base for all those constant reference classes can be directly used to refer fields. It provides `present()` for testing the presence of the value and other functions to query meta data such as `name()`, `id()`, or `field_type()`.\r\n\r\nThe classes to the left of `field_cref` represent the references for the FAST primitive types. All references classes for numeric types provides a `value()`\r\nmember function. The references classes for string and vector types provides interfaces like the const member function of `std::string` and `std::vector<T>` respectively.\r\n\r\n`group_cref` and `sequence_cref`, representing group and sequence types in FAST, provides access to the nested fields or elements respectively. The `sequenece_element_cref` class is used to represent the elements in a sequence. It does not inherit from `field_cref` because it does not correspond to a field in FAST sense. The class `nested_message_cref`, on the other hand, represents  templateRef in FAST. The class `message_cref`, corresponding to  *template* in FAST, is the base class for topmost level application types. The class `aggregate_cref` provides an abstraction to represent a collection of fields regardless whether the containing type is a group, a message or a element in a sequence.\r\n\r\nIn the `MDRefreshSample` example, to read the contained fields, we need to use `cref()` to obtain an`MDRefreshSample_cref` object. The generated `MDRefreshSample_cref` class has a set of `get_xxx()` member functions, where `xxx` is the field names, used for reading a field value. Likewise, a set of `set_xxx()` member functions is generated for writing field values in `MDRefreshSample_mref`. All getter/setter member functions return constant and mutable reference objects of their corresponding field types. This is very different from Google protocol buffer where simple value are returned from getters or passed as parameter to setters.\r\n\r\nHere is an example for reading field values in mFAST.\r\n\r\n```\r\nusing namespace mfast;\r\nvoid print_sample(const example::MDRefreshSample_cref& ref)\r\n{\r\n  cout << ref.get_BeginString().name() << \" : \" << ref.get_BeginString().c_str() << \"\\n\";\r\n  if (ref.get_ApplVerID().present())\r\n     cout << ref.get_ApplVerID().name() << \" : \" << ref.get_ApplVerID().c_str() << \"\\n\";\r\n  cout << ref.get_MsgSeqNum().name() << \" : \" << ref.get_MsgSeqNum().value() << \"\\n\";\r\n\r\n  for (auto entry : ref.get_MDEntries()) {\r\n     cout << entry.get_MDUpdateAction().name() << \" : \" << entry.get_MDUpdateAction().c_str();\r\n   // ...\r\n  }\r\n}\r\n\r\nexample::MDRefreshSample message;\r\n\r\n// message value is assigned somewhere else\r\n\r\nprint_sample(message.cref());\r\n```\r\n\r\nAll mutable reference classes are derived from the const reference counterpart. In other words, `int32_cref` is the base class of `int32_mref`, `seqence_cref` is the base class of `sequence_mref`, etc. However, `field_mref` is not the base class of more specific mutable  reference classes for fields such as `int32_mref` or `sequence_mref`; instead, those classes have an explicit type conversion constructor so that it's possible to  `static_cast` from a `field_mref` object to a more specific mutable reference object. The following code demonstrates how to assign fields values.\r\n\r\n```\r\nusing namespace mfast;\r\nexample::MDRefreshSample message;\r\nexample::MDRefreshSample_mref ref = message.mref();\r\nmref.set_ApplVerID().as(\"A\");\r\nassert(mref.get_ApplVerID().present());\r\n\r\nmref.set_SenderCompID.as(\"B\");\r\nmref.set_MsgSeqNum().as(1);\r\nauto entries = mref.set_MDEntries();\r\nentries.resize(4);\r\nentries[0].set_MDUpdateAction(1);\r\n// ...\r\n\r\n// using omit_xxx() to make optional field absent after assigning value \r\nmref.omit_ApplVerID();\r\nassert(!mref.get_ApplVerID().present());\r\nassert(mref.get_ApplVerID().size() == 0);\r\n\r\n// clear() can also make optional field absent \r\nmref.set_ApplVerID(\"A\");\r\nassert(mref.get_ApplVerID().present());\r\nmref.set_ApplVerID().clear();\r\nassert(!mref.get_ApplVerID().present());\r\nassert(mref.get_ApplVerID().size() == 0);\r\n\r\n\r\n// However, clear() make the size to 0 for \r\n// mandatory vectors, strings and sequences.\r\n\r\nassert(mref.set_SenderCompID.present());\r\nassert(mref.set_SenderCompID.size() == 1);\r\n\r\nmref.set_SenderCompID.clear(); // becomes zero length string\r\nassert(mref.set_SenderCompID.present());\r\nassert(mref.set_SenderCompID.size() == 0);\r\n```\r\n\r\nNotice that mFAST reference objects are like C/C++ build-in pointers in that no logic is involved to track the lifetime of the field/value they refer to; i.e. no reference counting is employed. Once a top level value holder object is destroyed, all the references stem from that value holder object become dangling references. Therefore, it is very important that a reference object cannot be used when its value holder object is destroyed. However, it is possible to create a new value holder object from an existing constant reference object, i.e. object cloning, so that the new value holder has a different lifetime than the object from which it was cloned.\r\n\r\nReference objects are small and inexpensive to copy: a constant reference object contains only 2 pointers internally while a mutable reference object contains 3 pointers. Because no reference counting is involved, copying a reference object does not impede efficiency by damaging cache performance and creating pipeline bubbles.\r\n\r\n\r\n### Decoding/Encoding FAST Messages\r\n\r\nFAST encoding rules require both the encoder and decoder to agree on a set of templates which can be used for the encoded stream. In mFAST, we use a `templates_description` object to package all the meta information on the set of templates needed by FAST encoder/decoder. For each FAST template XML file, `fast_type_gen` would generated a `templates_description` a free function named `description()`, which returns a pointer to a templates_description object, nested inside its own namespace. Before we can use the encoder/decoder, we must initialize it an array of pointer to `templates_description` objects. Here is an example how to initialize the mFAST decoder.\r\n\r\n```\r\nconst mfast::templates_description* descriptions[] = {\r\nexample::description()  // generated from fast_type_gen\r\n};\r\n\r\nmfast::fast_decoder decoder;\r\n\r\n// In current implementation, decoder.include() can only be called\r\n// exactly once per decoder/encoder\r\ndecoder.include(descriptions);\r\n```\r\n\r\nIn certain case, it might not be possible to decide the set of templates to use at compile time. mFAST also provides an alternative approach to generate the `templates_description` object at runtime with a string of FAST XML templates.\r\n\r\n```\r\nconst char* xml_content = \"<templates xmlns=\\\"http://www.fixprotocol.org/ns/template-definition\\\" ... </templates>\";\r\nmfast::dynamic_templates_description description(xml_content);\r\nconst mfast::templates_description* descriptions[] = {\r\n&description\r\n};\r\nmfast::fast_decoder decoder;\r\ndecoder.include(descriptions);\r\n```\r\n\r\nAfter the decoder is properly initialized, we can decode a buffer as follows:\r\n\r\n```\r\nconst char* first = buf;\r\nconst char* last = buf + buf_len;\r\n\r\ntry {\r\n  whille (first != last) {\r\n    mfast::message_cref msg = decoder.decode(first, last);\r\n    // Caveat 1: the variable *first* would be updated to the start of next unread position after decode().\r\n    // Caveat 2: msg is only valid before next decoder.decode() is called or decoder object is destroyed.\r\n\r\n    if (msg.id() == MarketData_cref::the_id)\r\n    {\r\n        MarketData_cref sample = static_cast<MarketData_cref>(msg);\r\n        print_sample(sample);\r\n    }\r\n  }\r\n}\r\ncatch (boost::exception& ex) {\r\n  // error handling\r\n}\r\n```\r\n\r\nSimilarly, encoding an application type into a `vector<char>` is as follows:\r\n\r\n```\r\nmfast::fast_encoder encoder;\r\nencoder.include(descriptions);\r\nstd::vector<char> buffer;\r\nbuffer.reserve(1024);\r\n\r\nexample::MDRefreshSample message;\r\n// ...  write fields into message\r\n\r\nencoder.encode(message.cref(), buffer);\r\n```\r\n\r\n### Memory Management\r\nTo maximize runtime efficiency, mFAST  has an `mfast::allocator` abstract class for customizing the memory allocation strategy. The constructors of `fast_encoder`, `fast_decoder` and all generated types derived from `mfast::message_type` take a pointer to  `mfast::allocator` as an optional parameter. If the parameter is not supplied, the system would use a global allocator implemented in  `malloc()`,  `realloc()` and `free()`. If the parameter is supplied, caution must be taken that the  allocator out-live the objects using the allocator.\r\n\r\nSuppose you implemented an allocator class called `memory_pool_alloactor`, the following demonstrates the incorrect and correct usage of allocators in mFAST.\r\n\r\n```\r\nmfast::message_cref get_message1(const char* buf, size_t sz)\r\n{\r\n  memory_pool_alloactor alloc;\r\n  mfast::fast_decoder decoder(&alloc);\r\n  decoder.include(descriptions);\r\n  return decoder.decode(buf, buf+sz); // WRONG, the returned message_cref out-lives the decoder and alloc objects which it stems from.\r\n}\r\n\r\nmemory_pool_alloactor msg_alloc;\r\nmessage_type msg(&msg_alloc);\r\n\r\nvoid get_message2(const char* buf, size_t sz)\r\n{\r\n  memory_pool_alloactor alloc;\r\n  mfast::fast_decoder decoder(&alloc);\r\n  decoder.include(descriptions);\r\n  mfast::message_cref ref=decoder.decode(buf, buf+sz);\r\n  msg = mfast::message_type(ref, &msg_alloc); // OK, copy construct a temporary message_type object\r\n                                              // and then move it to msg. mFAST uses boost::move to\r\n                                              // simulate rvalue reference in C++03.\r\n}\r\n```\r\n\r\n### mFAST Visitor\r\nAlthough it is generally much easier to access application types  using the getters/setters functions, as we have introduced, this might not be best way in certain situation such as logging the received messages in a human readable format. Using the getters to write a message logger requires prior knowledge of the application types and the logger functions may differ based on the application types. This kind of code tends to be unmanageable as the number of application types grows.\r\n\r\nmFAST provides a better way to cope with the above scenario using the visitor pattern. The visitor pattern allows the separation of an object structure and the operations which operate on it without modifying the structure itself. To be more specific, in the context mFAST, you write a visitor class which has a set of overloaded `visit()` member functions. Each `visit()` member function takes an argument of concrete mFAST field reference types such as `int32_cref`, `ascii_string_cref` and `sequence_cref`, etc. You then create an instance of the visitor class at runtime and invoke the `accept()` member function of `message_cref` or `message_mref` with the parameter of the visitor object. Next, the `visit()` member functions will be called in the sequence of the fields contained in the message object.\r\n\r\nThere are two categories of the visitor class in mFAST: *accessor* and *mutator*. An accessor visitor is used to read the fields in a message object; therefore, the `visit()` member functions in the accessor visitor class only take constant reference objects as their arguments. Conversely, a mutator visitor is used to modify the fields in a message object so the `visit()` member functions in the mutator visitor class only take mutable reference objects as their arguments.\r\nThe follow example shows how to print an arbitrary mFAST message object without the knowledge of the fields in the message.\r\n\r\n```\r\nusing namespace mfast;\r\n\r\n// a generic message accessor\r\nstruct message_printer\r\n{\r\n  std::ostream& os_;\r\n  indenter indent_;\r\n\r\n  enum {\r\n    visit_absent = 0 // indicating absent fields should not be visited\r\n  };\r\n\r\n  message_printer(std::ostream& os)\r\n  : os_(os)\r\n  {\r\n  }\r\n\r\n  template <typename PrimitiveTypes>\r\n  void visit(const PrimitiveTypes& ref) const\r\n  { // for int_cref<T>, decimal_cref, string_cref<T>, byte_vector_cref\r\n    // and int_vector_cref<T>\r\n      std::cout << indenter_ << ref.name() << \":\" << ref << \"\\n\";\r\n  }\r\n\r\n  template <typename CompositeTypeRef>\r\n  void visit(const CompositeTypeRef& ref, int) const\r\n  { // for group_cref, sequence_cref, nested_cref\r\n\r\n    os_ << indent_ << ref.name() << \":\\n\";\r\n    ++indent_;\r\n    ref.accept_accessor(*this);\r\n    --indent_;\r\n  }\r\n\r\n  void visit(const sequence_element_cref&  ref, int index) const\r\n  {\r\n    os_ << indent_ <<  \"[\" << index << \"]:\\n\";\r\n    ++indent_;\r\n    ref.accept_accessor(*this);\r\n    --indent_;\r\n  }\r\n};\r\n\r\nstd::ostream& operator << (std::ostream& os, const mfast::message_cref& ref)\r\n{\r\n  message_printer printer(os);\r\n  ref.accept_accessor(printer);\r\n  return os;\r\n}\r\n```\r\n\r\nA few things must be noted for the above example.\r\n  - A constant value `visit_absent` must be defined in a visitor class to indicate whether the absent fields should be visitor (0) or not (1).\r\n  - If you are familiar with the visitor pattern, you might be puzzled why the visit class does not use inheritance and virtual functions. In fact, we do use inheritance and virtual functions internally. We just wrap it so that a user  can write generic `visitor()` functions to combine several `visit()` member functions into one.\r\n  - The `visit()` function for primitive types always take exactly one argument and those for non-primitive types always take `int` as second argument. This `int` argument is used for differentiation purposes only except for that for sequence\\_element\\_cref. In this case, the second argument is the zero based index of the passed-in element in the parent sequence object.\r\n  - In the `visit()` member functions for non-primitive type, the line `ref.accept_accessor(*this);` (or `ref.accept_mutator(*this);` for mutator visitor classes) should be called; otherwise, the fields nested inside the group, sequence or templateRef won't be processed.\r\n\r\n\r\n\r\nConclusion\r\n------------------\r\n\r\nIn this article, we introduced the newly designed framework for serializing application data using FAST encoding rule. The approaches employed in the implementation of mFAST allowed a slimmer and far more efficient encoder and decoder. With the use of design patterns, it is also easier to develop applications with mFAST.\r\n\r\nHowever, mFAST at the current stage is not a complete replacement for QuickFAST. First of all, mFAST APIs are entirely different from QuickFAST. This makes it difficult to migrate existing applications from QuickFAST to mFAST. Second, QuickFAST has built-in modules for session management while mFAST is purely for data serialization. Therefore, if session management is essential, QuickFAST does provide that capability.\r\n\r\nWe are very excited about the development of mFAST so far and believe it has  potential to emerge from purely streaming FAST protocol to a more general serialization purpose for different formats. With the built-in reflective type system and visitor pattern support in its core, it is relatively easy to develop new encoding/decoding formats (such as FIX, JSON, Google Protocol Buffer) non-intrusively. For example, we already have a JSON encoder with only 140 lines of source code.\r\n\r\nCurrently, mFAST supports FAST specification version 1.1 only. Version 1.2 support is still under development.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}