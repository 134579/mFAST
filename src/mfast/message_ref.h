// Copyright (c) 2013, Huang-Ming Huang,  Object Computing, Inc.
// All rights reserved.
//
// This file is part of mFAST.
//
//     mFAST is free software: you can redistribute it and/or modify
//     it under the terms of the GNU Lesser General Public License as published by
//     the Free Software Foundation, either version 3 of the License, or
//     (at your option) any later version.
//
//     mFAST is distributed in the hope that it will be useful,
//     but WITHOUT ANY WARRANTY; without even the implied warranty of
//     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//     GNU General Public License for more details.
//
//     You should have received a copy of the GNU Lesser General Public License
//     along with mFast.  If not, see <http://www.gnu.org/licenses/>.
//
#ifndef MESSAGE_REF_H_CZBMHN6L
#define MESSAGE_REF_H_CZBMHN6L

#include <cassert>
#include <boost/move/core.hpp>
#include "mfast/field_instruction.h"
#include "mfast/allocator.h"
#include "mfast/field_ref.h"
#include "mfast/group_ref.h"
// #include "mfast/nested_message_ref.h"
namespace mfast {

// forwared declaration;
template <typename ConstMessageRef>
class make_message_mref;

struct fast_decoder_impl;


class unbouned_templateref_error
  : public virtual boost::exception, public virtual std::exception
{
  public:
    unbouned_templateref_error()
    {
    }

};

class message_cref
  : private detail::field_storage_helper
{
  public:

    typedef boost::false_type is_mutable;
    typedef boost::false_type canbe_optional;
    typedef const template_instruction* instruction_cptr;

    message_cref(const value_storage* storage,
                 instruction_cptr     instruction);


    explicit message_cref(const field_cref& cref);

    uint32_t id() const;

    const char* ns() const;

    const char* template_ns() const;

    const char* name() const;

    operator aggregate_cref() const;

    size_t fields_count() const;

    field_cref const_field(size_t index) const;

    /// return -1 if no such field is found
    int field_index_with_id(size_t id) const;

    /// return -1 if no such field is found
    int field_index_with_name(const char* name) const;

    const template_instruction* instruction() const;

    // const field_instruction* subinstruction(size_t index) const;

    template <typename FieldAccesor>
    void accept_accessor(FieldAccesor&) const;

  protected:
    const value_storage* storage() const;

    const template_instruction* instruction_;
    const value_storage* storage_;

    friend class detail::field_storage_helper;
};

template <typename ConstMessageRef>
class make_message_mref
  : public make_group_mref<ConstMessageRef>
{
  typedef make_group_mref<ConstMessageRef> base_type;

  public:
    typedef boost::true_type is_mutable;
    typedef typename base_type::instruction_cptr instruction_cptr;

    make_message_mref(mfast::allocator* alloc,
                      value_storage*    storage,
                      instruction_cptr  instruction);


    explicit make_message_mref(const field_mref_base& other);

    template <typename FieldMutator>
    void accept_mutator(FieldMutator&) const;

  private:
    friend class detail::codec_helper;
    // Used by decoder to indicate this object uses arena allocator,
    // and the allocator has been resetted. All previously allocated memory
    // are invalidated. Thus memory for sub-fields needs to be re-allocated.
    void reset() const;
};

typedef make_message_mref<message_cref> message_mref;

template <>
struct mref_of<message_cref>
{
  typedef message_mref type;
};

////////////////////////////

inline
message_cref::message_cref(const value_storage*        storage,
                           const template_instruction* instruction)
  : instruction_(instruction)
  , storage_(storage)
{
}

inline
message_cref::message_cref(const field_cref& cref)
  : instruction_(static_cast<const template_instruction*>(cref.instruction()))
  , storage_(storage_ptr_of(cref))
{
  switch (cref.instruction()->field_type())
  {
  case field_type_template:
    instruction_ = static_cast<const template_instruction*> (cref.instruction());
    break;
  case field_type_templateref:
    instruction_ = static_cast<const template_instruction*> (storage_of(cref).of_templateref.of_instruction.instruction_);
    if (instruction_ == 0)
      BOOST_THROW_EXCEPTION(unbouned_templateref_error());
    // if you hit the exeception, you have to use dynamic_nested_message_mref::rebind() to bind a valid
    // template_instruction intead. If this is a static templateRef, please use the resolved templates
    // provided by encoder or those generated by fast_type_gen.
    break;
  default:
    instruction_ =0;
  }
}

inline size_t
message_cref::fields_count() const
{
  return instruction_->subinstructions_count_;
}

inline uint32_t
message_cref::id() const
{
  return instruction_->id();
}

inline const char*
message_cref::ns() const
{
  return instruction_->ns();
}

inline const char*
message_cref::template_ns() const
{
  return instruction_->template_ns();
}

inline const char*
message_cref::name() const
{
  return instruction_->name();
}

inline
message_cref::operator aggregate_cref() const
{
  return aggregate_cref(storage_->of_group.content_, instruction_);
}

inline field_cref
message_cref::const_field(std::size_t index) const
{
  return aggregate_cref(*this).const_field(index);
}

/// return -1 if no such field is found
inline int
message_cref::field_index_with_id(std::size_t id) const
{
  return aggregate_cref(*this).field_index_with_id(id);
}

inline int
message_cref::field_index_with_name(const char* name) const
{
  return aggregate_cref(*this).field_index_with_name(name);
}

inline const template_instruction*
message_cref::instruction() const
{
  return instruction_;
}

inline const value_storage*
message_cref::storage() const
{
  return storage_;
}

///////////////////////////////////////////////////////

template <typename ConstMessageRef>
inline
make_message_mref<ConstMessageRef>::make_message_mref(mfast::allocator*                                             alloc,
                                                      value_storage*                                                storage,
                                                      typename make_message_mref<ConstMessageRef>::instruction_cptr instruction)
  : base_type(alloc, storage, instruction)
{
}

template <typename ConstMessageRef>
inline
make_message_mref<ConstMessageRef>::make_message_mref(const field_mref_base& other)
  : base_type(other)
{
}

template <typename ConstMessageRef>
inline void
make_message_mref<ConstMessageRef>::reset() const
{
  const_cast<value_storage*>(this->storage_)->of_group.content_ = 0;
}

}
#endif /* end of include guard: MESSAGE_REF_H_CZBMHN6L */
